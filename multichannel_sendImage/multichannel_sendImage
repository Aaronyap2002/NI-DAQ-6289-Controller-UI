#Write multiple column data without using the image upload and processing.

import nidaqmx
import numpy as np
from nidaqmx.constants import AcquisitionType, TerminalConfiguration, Edge
from nidaqmx.stream_readers import AnalogMultiChannelReader
from nidaqmx.stream_writers import AnalogMultiChannelWriter
import time

def prepare_multichannel_data(file_path, num_channels, samples_per_channel):
    # Read the data from the text file
    with open(file_path, 'r') as f:
        data = np.array([line.strip().split('\t') for line in f if line.strip()], dtype=float)
    
    # If the data has fewer columns than num_channels, pad with zeros
    if data.shape[1] < num_channels:
        padding = np.zeros((data.shape[0], num_channels - data.shape[1]))
        data = np.hstack((data, padding))
    elif data.shape[1] > num_channels:
        # If we have more columns than expected, truncate
        data = data[:, :num_channels]
    
    # Transpose the data so that each row represents a channel
    write_data = data.T
    
    # Ensure we have the correct number of samples
    if write_data.shape[1] < samples_per_channel:
        # Pad with zeros if we have fewer samples than expected
        write_data = np.pad(write_data, ((0, 0), (0, samples_per_channel - write_data.shape[1])), mode='constant')
    elif write_data.shape[1] > samples_per_channel:
        # Truncate if we have more samples than expected
        write_data = write_data[:, :samples_per_channel]
    
    # Ensure the array is C-contiguous
    return np.ascontiguousarray(write_data)

# Constants
SAMPLE_RATE = 2000
SAMPLES_PER_CHANNEL = 10000
NUM_CHANNELS = 4

# Prepare write data from file
file_path = 'combined_channels.txt'  # Make sure this file exists and contains your data
write_data = prepare_multichannel_data(file_path, NUM_CHANNELS, SAMPLES_PER_CHANNEL)

read_data = np.zeros((NUM_CHANNELS, SAMPLES_PER_CHANNEL))

with nidaqmx.Task() as read_task, nidaqmx.Task() as write_task:
    # Setup channels
    for i in range(NUM_CHANNELS):
        read_task.ai_channels.add_ai_voltage_chan(f"Dev1/ai{i}", terminal_config=TerminalConfiguration.RSE, min_val=-10.0, max_val=10.0)
        write_task.ao_channels.add_ao_voltage_chan(f"Dev1/ao{i}", min_val=-10.0, max_val=10.0)

    # Configure timing for both tasks
    write_task.timing.cfg_samp_clk_timing(rate=SAMPLE_RATE,
                                          sample_mode=AcquisitionType.FINITE,
                                          samps_per_chan=SAMPLES_PER_CHANNEL)
    read_task.timing.cfg_samp_clk_timing(rate=SAMPLE_RATE, 
                                         source="ao/SampleClock",
                                         sample_mode=AcquisitionType.FINITE,
                                         samps_per_chan=SAMPLES_PER_CHANNEL,
                                         active_edge=Edge.RISING)
    read_task.timing.delay_from_samp_clk_delay_units = nidaqmx.constants.DigitalWidthUnits.SECONDS
    read_task.timing.delay_from_samp_clk_delay = 0.5/SAMPLE_RATE # update this with the value in seconds to delay
    
    # Create reader and writer
    reader = AnalogMultiChannelReader(read_task.in_stream)
    writer = AnalogMultiChannelWriter(write_task.out_stream)

    # Write data
    writer.write_many_sample(write_data)

    # Start tasks
    read_task.start()
    start_time = time.perf_counter()
    write_task.start()

    # Read data
    reader.read_many_sample(read_data, number_of_samples_per_channel=SAMPLES_PER_CHANNEL)
    
    end_time = time.perf_counter()

# Write input and output channel values to a text file
with open("multichannel_sendImage channel_values.txt", "w") as file:
    for i in range(SAMPLES_PER_CHANNEL):
        file.write(f"Sample {i}:\n")
        for j in range(NUM_CHANNELS):
            file.write(f"  AI{j}: {read_data[j, i]:.6f}V, AO{j}: {write_data[j, i]:.6f}V\n")

# Verify data
error = np.abs(write_data - read_data)
max_error = np.max(error)
avg_error = np.mean(error)
print(f"Max error: {max_error:.6f}V")
print(f"Average error: {avg_error:.6f}V")

for i in range(NUM_CHANNELS):
    channel_error = np.abs(write_data[i] - read_data[i])
    channel_max_error = np.max(channel_error)
    channel_avg_error = np.mean(channel_error)
    print(f"Channel {i}: Max error: {channel_max_error:.6f}V, Avg error: {channel_avg_error:.6f}V")

expected_duration = SAMPLES_PER_CHANNEL / SAMPLE_RATE
actual_duration = end_time - start_time
print(f"Expected duration: {expected_duration:.6f}s")
print(f"Actual duration: {actual_duration:.6f}s")
print(f"Timing error: {abs(actual_duration - expected_duration):.6f}s")

# Print first few samples
for i in range(5):
    print(f"Time: {i/SAMPLE_RATE:.6f}s, " + 
          ", ".join([f"AI{j}: {read_data[j,i]:.3f}V, AO{j}: {write_data[j,i]:.3f}V" for j in range(NUM_CHANNELS)]))

print(f"Shape of write_data: {write_data.shape}")
print(f"Shape of read_data: {read_data.shape}")
